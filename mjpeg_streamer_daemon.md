# mjpeg streamer daemon

These instructions were originally for raspbian, the git clonable files are here: https://github.com/ntoff/mjpeg-streamer-octoprint-daemon They may be a little bit specific to raspbian so here's the contents
of the files all laid out. These are not the instructions on how to install mjpeg streamer, this is just a collection of scripts to daemonize it (intended to be used when octoprint has been manually installed, as opposed to using the pre-built octopi image).

## /bin/webcamd

Create the file `/bin/webcamd` and make it executable.

Don't forget to edit `MJPGSTREAMER_HOME=/home/pi/mjpg-streamer/mjpg-streamer-experimental` to point to the actual directory.

Also on raspbian there is the /boot  partition which is easily accessible from windows machines to make editing the configuration files a bit easier,
if you're installing this on your main (linux only) computer, you may also wish to edit

    if [ -e "/boot/octopi.txt" ]; then
            source "/boot/octopi.txt"
    fi
and make it point to a different file, perhaps a file in your own user home directory.

    #!/bin/bash
    
    ########################################################################
    ### DO NOT EDIT THIS FILE TO CHANGE THE CONFIG!!!                    ###
    ### ---------------------------------------------------------------- ###
    ### There is no need to edit this file for changing resolution,      ###
    ### frame rates or any other mjpg-streamer parameters. Please edit   ###
    ### /boot/octopi.txt instead - that's what it's there for! You can   ###
    ### even do this with your Pi powered down by directly accessing the ###
    ### file when using the SD card as thumb drive in your regular       ###
    ### computer.                                                        ###
    ########################################################################
    
    MJPGSTREAMER_HOME=/home/pi/mjpg-streamer/mjpg-streamer-experimental
    MJPGSTREAMER_INPUT_USB="input_uvc.so"
    MJPGSTREAMER_INPUT_RASPICAM="input_raspicam.so"
    
    # init configuration - DO NOT EDIT, USE /boot/octopi.txt INSTEAD!
    camera="auto"
    camera_usb_options="-r 640x480 -f 10"
    camera_raspi_options="-fps 10"
    additional_brokenfps_usb_devices=()
    
    if [ -e "/boot/octopi.txt" ]; then
        source "/boot/octopi.txt"
    fi
    
    brokenfps_usb_devices=("046d:082b" "${additional_brokenfps_usb_devices[@]}")
    
    # cleans up when the script receives a SIGINT or SIGTERM
    function cleanup() {
        # make sure that all child processed die when we die
        local pids=$(jobs -pr)
        [ -n "$pids" ] && kill $pids
        exit 0
    }
    
    # says goodbye when the script shuts down
    function goodbye() {
        # say goodbye
        echo ""
        echo "Goodbye..."
        echo ""
    }
    
    # runs MJPG Streamer, using the provided input plugin + configuration
    function runMjpgStreamer {
        input=$1
        pushd $MJPGSTREAMER_HOME > /dev/null 2>&1
            echo Running ./mjpg_streamer -o "output_http.so -w ./www" -i "$input"
            LD_LIBRARY_PATH=. ./mjpg_streamer -o "output_http.so -w ./www" -i "$input" &
            wait
        popd > /dev/null 2>&1
    }
    
    # starts up the RasPiCam
    function startRaspi {
        logger -s "Starting Raspberry Pi camera"
        runMjpgStreamer "$MJPGSTREAMER_INPUT_RASPICAM $camera_raspi_options"
    }
    
    # starts up the USB webcam
    function startUsb {
        options="$camera_usb_options"
        device="video0"
        
        extracted_device=`echo $options | sed 's@.*-d /dev/\(video[0-9]+\).*@\1@'`
        if [ "$extracted_device" != "$options" ]
        then
            # the camera options refer to another device, use that for determining product
            device=$extracted_device
        fi
    
        uevent_file="/sys/class/video4linux/$device/device/uevent"
        if [ -e $uevent_file ]; then
            # let's see what kind of webcam we have here, fetch vid and pid...
            product=`cat $uevent_file | grep PRODUCT | cut -d"=" -f2`
            vid=`echo $product | cut -d"/" -f1`
            pid=`echo $product | cut -d"/" -f2`
            vidpid=`printf "%04x:%04x" "0x$vid" "0x$pid"` 
    
            # ... then look if it is in our list of known broken-fps-devices and if so remove
            # the -f parameter from the options (if it's in there, else that's just a no-op)
            for identifier in ${brokenfps_usb_devices[@]};
            do
                if [ "$vidpid" = "$identifier" ]; then
                    echo
                    echo "Camera model $vidpid is known to not work with -f parameter, stripping it out"
                    echo
                    options=`echo $options | sed -e "s/\(\s\+\|^\)-f\s\+[0-9]\+//g"`
                fi
            done
        fi
    
        logger -s "Starting USB webcam"
        runMjpgStreamer "$MJPGSTREAMER_INPUT_USB $options"
    }
    
    # make sure our cleanup function gets called when we receive SIGINT, SIGTERM
    trap "cleanup" SIGINT SIGTERM
    # say goodbye when we EXIT
    trap "goodbye" EXIT
    
    # echo configuration
    echo "Starting up webcamDaemon..."
    echo ""
    echo "--- Configuration: ----------------------------"
    echo "camera:        $camera"
    echo "usb options:   $camera_usb_options"
    echo "raspi options: $camera_raspi_options"
    echo "-----------------------------------------------"
    echo ""
    
    # we need this to prevent the later calls to vcgencmd from blocking
    # I have no idea why, but that's how it is...
    vcgencmd version > /dev/null 2>&1
    
    # keep mjpg streamer running if some camera is attached
    while true; do
        if [ -e "/dev/video0" ] && { [ "$camera" = "auto" ] || [ "$camera" = "usb" ] ; }; then
            startUsb
            sleep 30 &
            wait
        elif [ "`vcgencmd get_camera`" = "supported=1 detected=1" ] && { [ "$camera" = "auto" ] || [ "$camera" = "raspi" ] ; }; then
            startRaspi
            sleep 30 &
            wait
        else
            echo "No camera detected, trying again in two minutes"
            sleep 120 &
            wait
        fi
    done

## /etc/default/webcamd

Create `/etc/default/webcamd` (no need to make this executable) and don't forget to edit the user!

    # Configuration for /etc/init.d/webcamd
    
    # Daemon
    DAEMON=/bin/webcamd
    
    # Log file to use
    LOG=/var/log/webcamd.log
    
    # User to run under
    USER=pi
    
    # Should we run at startup?
    ENABLED=1

## /etc/init.d/webcamd

Create `/etc/init.d/webcamd` and make it executable

Don't forget to edit the user `USER=pi`! The default user is "pi" (as these scripts were taking from octopi) and while that's usually the default user under raspbian where these scripts were intended,
you may wish to set this user to a different one to suit your needs.

    #!/bin/sh
    
    ### BEGIN INIT INFO
    # Provides:          webcamd
    # Required-Start:    $local_fs networking
    # Required-Stop:
    # Should-Start:
    # Should-Stop:
    # Default-Start:     2 3 4 5
    # Default-Stop:      0 1 6
    # Short-Description: webcam daemon
    # Description:       Starts the OctoPi webcam daemon with the user specified config in
    #                    /etc/default/webcamd.
    ### END INIT INFO
    
    # Author: Gina Haeussge
    
    PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin
    DESC="Webcam Daemon"
    NAME="webcamd"
    DAEMON=/bin/webcamd
    USER=pi
    PIDFILE=/var/run/$NAME.pid
    PKGNAME=webcamd
    SCRIPTNAME=/etc/init.d/$PKGNAME
    LOG=/var/log/webcamd.log
    
    # Read configuration variable file if it is present
    [ -r /etc/default/$PKGNAME ] && . /etc/default/$PKGNAME
    
    # Exit if the octoprint is not installed
    [ -x "$DAEMON" ] || exit 0
    
    # Load the VERBOSE setting and other rcS variables
    [ -f /etc/default/rcS ] && . /etc/default/rcS
    
    # Define LSB log_* functions.
    # Depend on lsb-base (>= 3.0-6) to ensure that this file is present.
    . /lib/lsb/init-functions
    
    if [ -z "$ENABLED" -o "$ENABLED" != "1" ]
    then
       log_warning_msg "Not starting $PKGNAME, edit /etc/default/$PKGNAME to start it."
       exit 0
    fi
    
    #
    # Function to verify if a pid is alive
    #
    is_alive()
    {
       pid=`cat $1` > /dev/null 2>&1
       kill -0 $pid > /dev/null 2>&1
       return $?
    }
    
    #
    # Function that starts the daemon/service
    #
    do_start()
    {
       # Return
       #   0 if daemon has been started
       #   1 if daemon was already running
       #   2 if daemon could not be started
    
       is_alive $PIDFILE
       RETVAL="$?"
    
       if [ $RETVAL != 0 ]; then
           start-stop-daemon --start --background --no-close --quiet --pidfile $PIDFILE --make-pidfile \
           --startas /bin/bash --chuid $USER --user $USER -- -c "exec $DAEMON" >> $LOG 2>&1
           RETVAL="$?"
       fi
    }
    
    #
    # Function that stops the daemon/service
    #
    do_stop()
    {
       # Return
       #   0 if daemon has been stopped
       #   1 if daemon was already stopped
       #   2 if daemon could not be stopped
       #   other if a failure occurred
    
       start-stop-daemon --stop --quiet --retry=TERM/30/KILL/5 --user $USER --pidfile $PIDFILE
       RETVAL="$?"
       [ "$RETVAL" = "2" ] && return 2
    
       rm -f $PIDFILE
    
       [ "$RETVAL" = "0"  ] && return 0 || return 1
    }
    
    case "$1" in
      start)
       [ "$VERBOSE" != no ] && log_daemon_msg "Starting $DESC" "$NAME"
       do_start
       case "$?" in
          0|1) [ "$VERBOSE" != no ] && log_end_msg 0 ;;
          2) [ "$VERBOSE" != no ] && log_end_msg 1 ;;
       esac
       ;;
      stop)
       [ "$VERBOSE" != no ] && log_daemon_msg "Stopping $DESC" "$NAME"
       do_stop
       case "$?" in
          0|1) [ "$VERBOSE" != no ] && log_end_msg 0 ;;
          2) [ "$VERBOSE" != no ] && log_end_msg 1 ;;
       esac
       ;;
      restart)
       log_daemon_msg "Restarting $DESC" "$NAME"
       do_stop
       case "$?" in
         0|1)
          do_start
          case "$?" in
             0) log_end_msg 0 ;;
             1) log_end_msg 1 ;; # Old process is still running
             *) log_end_msg 1 ;; # Failed to start
          esac
          ;;
         *)
            # Failed to stop
          log_end_msg 1
          ;;
       esac
       ;;
      *)
       echo "Usage: $SCRIPTNAME {start|stop|restart}" >&2
       exit 3
       ;;
    esac

## Finishing up

If you haven't already made them executable, you can do so by typing

    sudo chmod +x /etc/init.d/webcamd
    sudo chmod +x /bin/webcamd
    
and updating the service defaults with

    sudo update-rc.d webcamd defaults

This should allow management of the service via

    sudo service webcamd start|stop|resetart
    
Also you may be required to add your user to the video group in order to access the camera

    sudo usermod -a -G video your_user_name






